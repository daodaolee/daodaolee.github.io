<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《重构 JavaScript》读后感和部分摘录</title>
    <meta name="description" content="A VitePress site">
    <link rel="stylesheet" href="/assets/style.b4de4daf.css">
    <link rel="modulepreload" href="/assets/chunks/Home.84031245.js">
    <link rel="modulepreload" href="/assets/chunks/Navbar.7a2e2f08.js">
    <link rel="modulepreload" href="/assets/chunks/Page.298bf9fa.js">
    <link rel="modulepreload" href="/assets/chunks/Post.8123d9ef.js">
    <link rel="modulepreload" href="/assets/chunks/Movie.e7531bdd.js">
    <link rel="modulepreload" href="/assets/app.ec7a89e7.js">
    <link rel="modulepreload" href="/assets/posts_refactor_js.md.76f8eb20.lean.js">
    
    <link rel="icon" href="/favicon.ico">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><div><header class="w-100vw p-6 flex items-center justify-between fixed" data-v-29c3ee47><a href="/" data-v-29c3ee47><img src="/logo-black.webp" class="w-10 h-10" data-v-29c3ee47></a><div class="nav-icons flex items-center gap-5" data-v-29c3ee47><!--[--><a target="_self" href="/posts/" class="cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="md:hidden" data-v-29c3ee47><div class="i-ri-article-line icon" data-v-29c3ee47></div></div><span text-sm ml-1 class="lt-md:hidden" data-v-29c3ee47>Posts</span></a><a target="_self" href="/movies/" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><!----><span text-sm ml-1 class="lt-md:hidden" data-v-29c3ee47>Movies</span></a><a target="_blank" href="https://github.com/daodaolee" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri:github-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://twitter.com/daodaolee_" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri:twitter-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://www.instagram.com/daodaoleee/" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri-instagram-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://dribbble.com/daodaolee" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri-dribbble-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://space.bilibili.com/294106298?spm_id_from=333.1007.0.0" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri-bilibili-fill icon" data-v-29c3ee47></div></div><!----></a><!--]--><a class="cursor-pointer op-60" data-v-29c3ee47><div class="i-ri:sun-line icon" data-v-29c3ee47></div></a></div></header><main class="content max-w-73ch mx-auto px-6 md:px-0 pb-15"><div class="pt-25"><div class="mb-8"><h1 class="title mt-0 text-2.2rem mb-5">《重构 JavaScript》读后感和部分摘录</h1><div class="op-60 flex items-end"><span>Mar 1, 2022</span><div class="text-0.85rem pl-1.8rem"><!--[--><span> #refacor  </span><span> #js  </span><!--]--></div></div></div><div style="position:relative;" class="page"><div><nav class="table-of-contents"><ul><li><a href="#前言">前言</a></li><li><a href="#介绍">介绍</a></li><li><a href="#摘录">摘录</a><ul><li><a href="#第1章-重构是什么">第1章： 重构是什么？</a></li><li><a href="#第2章-你使用哪种javascript">第2章：你使用哪种JavaScript？</a></li><li><a href="#第3章-测试">第3章：测试</a></li><li><a href="#第4章-测试实践">第4章：测试实践</a></li><li><a href="#第5章-基本重构目标">第5章：基本重构目标</a></li><li><a href="#第6章-重构基本结构">第6章：重构基本结构</a></li><li><a href="#第7章-重构函数与对象">第7章：重构函数与对象</a></li><li><a href="#第8章-层次结构中的重构">第8章：层次结构中的重构</a></li><li><a href="#第9章-重构到面向对象模式">第9章：重构到面向对象模式</a></li><li><a href="#第10章-重构异步">第10章：重构异步</a></li><li><a href="#第11章-函数式重构">第11章：函数式重构</a></li></ul></li></ul></nav><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><p>整体来说，《重构 JavaScript》对从刚入门到有些许开发经验的人，都有受益的地方。</p><p>前面讲述了在 JavaScript 里重构是一个什么概念，你应该怎么选择、学习和使用 JavaScript，以及讲测试对重构的重要性；中间讲述了重构的目标、要注意的结构和一些值得注意的点；最后提到了一些异步、模式和函数式编程的思路。</p><p><strong>可以这样形容：有一个密室，给你一些物品，然后从上帝视角告诉你物品的作用，以及你可以选择或参考的路线，也包括你可能走过的错误路线分析，最后告诉你如何走的更漂亮。</strong></p><p>其中比较有感触的地方就是：要相信你的代码，不要害怕测试，遵循一些特定的规范和模式，就可以把你的代码重构下去，如果愿意再学习一些新的思路，你的代码会更漂亮，你的项目会更健壮，你的技术（包括思想）会有质的飞跃。</p><h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-hidden="true">#</a></h2><p>下图是一张图书简介（取自某个在线商城）：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba15f1ccc7534e2dbd8c12a51177e890~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="摘录" tabindex="-1">摘录 <a class="header-anchor" href="#摘录" aria-hidden="true">#</a></h2><p>以下是文章里的一些摘录，个人感觉有很多值得学习和思考的地方，当然其中也有个人理解的成分。（部分专业术语没有做具体的介绍，因为太多了......）</p><h3 id="第1章-重构是什么" tabindex="-1">第1章： 重构是什么？ <a class="header-anchor" href="#第1章-重构是什么" aria-hidden="true">#</a></h3><ul><li><p>当我们进行测试时，我们有<strong>足够的信心</strong>重构代码并改变实现。如果没有这些测试，我们就是把我们真正关心的行为（输入和输出）置于危险之中。</p></li><li><p><strong>性能</strong>（和其他非功能性方面）是我们决定围绕它创建期望和测试的次要问题。</p></li><li><p>在过去的20年里，一个流行的比喻是<strong>技术债</strong>。</p></li><li><p>高质量的代码一般都有以下原则：</p><ul><li>SOLID：单一职责原则，开闭原则，里氏替换原则，接口隔离原则，依赖反转原则。</li><li>DRY：不做重复的事。</li><li>KISS：保持简单直接。</li><li>GRASP：通用职责分配软件模式。</li><li>YAGNI：你不会需要它。</li></ul></li><li><p><strong>将人的可读性视为质量</strong></p></li><li><p><strong>重构即探索</strong></p></li></ul><h3 id="第2章-你使用哪种javascript" tabindex="-1">第2章：你使用哪种JavaScript？ <a class="header-anchor" href="#第2章-你使用哪种javascript" aria-hidden="true">#</a></h3><ul><li><p>我应该使用哪个框架？</p><p>这是JavaScript 开发者经常提出的一个问题，而且可能是来自新开发人员最大的 问题，“我应该学习哪种语言？” 框架限定的工作方式可以给程序员一种他们 真的知道一切的感觉。<strong>用夸张甚至矛盾的要求来描述工作没有什么用</strong>。当涉及 JavaScript 时有很多框架、平台和最终不同类型的代码，你可能都会写到，这个 问题的某些形式会一次又一次地出现。</p><p>最后，<strong>你不可能学会一切</strong>。如果你有一个工作或目标工作真正需要某些技能，首 先花时间在那些事上面。如果你心中没有一份特别的工作，<strong>去聚会找朋友和导师</strong>， <strong>并跟着他们做</strong>。或者，如果你只想学习你感兴趣的东西，<strong>选择一些看起来很酷的</strong> <strong>东西</strong>，然后<strong>深入进去，继续前进</strong>，在某个时候，考愿娴熟掌握这些技术。</p><p>你可以在语言、框架、测试库或乐器上应用相同的过程（按照工作要求、朋友在 使用的和你认为酷的进行过滤）。在所有这些中，偶尔深入，如果你原谅一些粗 鲁的建议，<strong>请注意哪里钱多</strong>。</p><p>“看起来很酷” 可能听起来很模糊，确实如此。对我来说，这意味着要找到最新 奇或者最令人费解的技术。我不太可能学习14 种解决相同问题的变体。对一些 人来说，酷意味着新和时髦。对其他人来说，它意味着受欢迎或有利可图。如果 你不知道 “看起来很酷” 对你来说意味着什么，那就用一些可能性来解决这个问 题，<strong>而不是花太多时间考虑选择哪一个</strong>。</p></li><li><p><strong>框架</strong>这个术语被看得过重了。</p></li></ul><h3 id="第3章-测试" tabindex="-1">第3章：测试 <a class="header-anchor" href="#第3章-测试" aria-hidden="true">#</a></h3><ul><li><p>关于最后一个引用。</p><p>测试不是个问题。这种现象暗示了<strong>这是一个缺乏领导力的小型或缺乏经验团队</strong>。</p><p><strong>不幸的是，如果你在一个都是莽撞的人的团队中（这些程序员只是堆砌代码，而不重视质量和测试），最可能的结果是挫败感和不可预测的破坏（以及不可预知的时间）。</strong></p><p>“立即离开这个不好的团队” 不是唯一的答案，因为在这种情况下可能还有其他的好处和限制。但是<strong>一些注重质量的项目往往有更好的稳定性（更少的推翻重来），更好的薪酬和更多学习的机会。</strong></p><p>正常的老板或客户不会拒绝任何对软件是否正常工作的验证。</p></li><li><p>就像伊索寓言里的狐狸一样，没有抓到葡萄的时候，就说它们一定是酸的。如果保证软件质量的测试是很难的，那就一定是不重要的，对吗？<strong>这可能对让你面对人生中你无法控制的遗憾和失望是有帮助的</strong>，但如果没有认识到测试的好处，你就无法以一个完全不同的方式来写代码。<strong>葡萄不是酸的，不要像那只狐狸一样，你是可以找到一个梯子实现的。</strong></p></li><li><p><strong>测试的主要目的是对代码有信心。</strong> 这种信心不是凭空产生的。它是由看到错误和抵制变化的代码而产生的怀疑中形成的。信心是测试什么和如何测试的最佳指标。了解测试的最大原因是帮助你在查看代码库时建立自信和怀疑感。</p></li><li><p>每个测试方法都有三个阶段：<strong>设置、断言和回收。</strong></p></li></ul><h3 id="第4章-测试实践" tabindex="-1">第4章：测试实践 <a class="header-anchor" href="#第4章-测试实践" aria-hidden="true">#</a></h3><ul><li>在TDD（测试驱动开发）中，可以使用 <strong>红色/绿色/重构</strong> 周期来测试代码，换句话说：“测试失败，测试成功，优化之”。</li><li>在任何情况下，请保持 <code>git commit</code> 命令之间的步骤很小，以便你可以很容易回滚到干净的版本。</li></ul><h3 id="第5章-基本重构目标" tabindex="-1">第5章：基本重构目标 <a class="header-anchor" href="#第5章-基本重构目标" aria-hidden="true">#</a></h3><ul><li>相比只返回 <code>undefined</code>，返回 <code>this</code> 将提供更多的信息和更好的接口。</li><li>理想情况下，<strong>副作用</strong> 越少越好，如果必须存在，应该尽可能做到隔离。</li><li><code>IIFEs</code> 没有名字，也不能被寻址。</li><li>类有更多的特性，这些特性构成了独特的构造，而不仅仅是构造函数的 “语法糖”。</li><li>JavaScript 在 OOP 上翻了一番，函数式编程可能是 JavaScript 的 “未来”，但至少 OOP 也是未来。</li><li>尽量减少块（复杂度和代码行数）。</li><li>尽量减少输入的总数。</li><li>多使用显示输入。</li><li>相比副作用，多使用真实有意义的返回值。</li><li>将副作用降低到最小甚至不存在。</li></ul><h3 id="第6章-重构基本结构" tabindex="-1">第6章：重构基本结构 <a class="header-anchor" href="#第6章-重构基本结构" aria-hidden="true">#</a></h3><ul><li><p><strong>重命名</strong> 可能是件大事。</p></li><li><p><strong>注释</strong> 有时候可以用作文档，甚至可以建立外部文档。</p></li><li><p>“提取” 是一种特定类型的 “引入”，有时候它比函数更合适。</p></li><li><p>要注意 <strong>变量提升</strong>。</p></li><li><p>“for in” 有点像我们的 for 和 while 循环，但是我们没有处理索引更新，所以你可以把它看成 “for 索引 in”。</p><ul><li>for...in 中的索引不保证按顺序。</li><li>任何可枚举的属性都将被枚举，数组可以从其他地方继承 “enumerable” 属性。</li><li>在 for...in 循环中修改数组可能会导致混淆。</li></ul></li></ul><h3 id="第7章-重构函数与对象" tabindex="-1">第7章：重构函数与对象 <a class="header-anchor" href="#第7章-重构函数与对象" aria-hidden="true">#</a></h3><ul><li><p>映射（Map）是为了实现更轻量级的 “键和值” 。</p></li><li><p><code>WeakSet</code> 和 <code>WeakMap</code> 与它们的 “强” 版本的主要区别是：</p><ul><li>它们不能被迭代（没有 <code>forEach</code> 函数）。</li><li>它们没有获取容器大小的引用。</li><li>WeakSet 不能存储基本类型数据。</li><li>他们很 “弱” 地管理它们的键。也就是说，当键没有任何引用的时候可以被垃圾回收。</li></ul></li><li><p>使用 “弱” 形式时，你放弃了容易了解内部是什么或将函数应用到整个集合的能力。而你得到的是对内存泄漏和隐私的控制。</p></li><li><p>建议将 if 中多个布尔值的判断放到一个函数的返回值中。</p></li><li><p>尽量缩小全局变量的作用域，最好可以设计我们的API。</p></li></ul><h3 id="第8章-层次结构中的重构" tabindex="-1">第8章：层次结构中的重构 <a class="header-anchor" href="#第8章-层次结构中的重构" aria-hidden="true">#</a></h3><ul><li>要构建好逻辑的层次结构，尽量隔离。</li><li>构造函数经常会在原型上搞事情，所以不要它不是很好用，可以使用对象字面量和工厂函数来代替。</li><li>考虑好 <code>Is-A</code> 和 <code>Is-Just-A</code>。</li></ul><h3 id="第9章-重构到面向对象模式" tabindex="-1">第9章：重构到面向对象模式 <a class="header-anchor" href="#第9章-重构到面向对象模式" aria-hidden="true">#</a></h3><ul><li><strong>状态模式</strong> 的核心是愿意将可能被认为是 “属于” 某个对象的部分移动到另一个对象中。 OOP （面向对象编程）中有一种倾向，即将层次结构放在委托对象的优先级之上。</li><li><strong>装饰器</strong> 主要表现在将特性添加到现有的接口（实例）中。</li><li><strong>外观</strong> （对象字面量的方式来定义）看起来很简洁，坏处是不容易维护。</li></ul><h3 id="第10章-重构异步" tabindex="-1">第10章：重构异步 <a class="header-anchor" href="#第10章-重构异步" aria-hidden="true">#</a></h3><ul><li>将 “回调地狱” 变成 <strong>流式API</strong>，这种风格叫 <strong>CPS</strong>（延续传递风格）。</li><li><code>Promise</code> 的价值在于它们改变了接口，而这些可能就是你希望进行测试的地方。</li></ul><h3 id="第11章-函数式重构" tabindex="-1">第11章：函数式重构 <a class="header-anchor" href="#第11章-函数式重构" aria-hidden="true">#</a></h3><ul><li>在 FP（声明式编程）中，我们应该试图去强调，描述一个程序应该做什么，而不是应该怎么做。</li><li>纯函数的好处是幂等性，也就是作用域够小并且不能改变时，你可以总是相信同样的参数进去，返回的结果是一样的。另一个好处就是不产生副作用。</li><li>柯里化、函数组合是个好想法。</li></ul><blockquote><p>希望大家都可以成为心目中的大佬！</p></blockquote></div></div></div></main></div></div><div class="text-center text-[14px] pt-10 pb-2 scale-80 color-[black]" style="letter-spacing:0.2rem;"><a href="https://beian.miit.gov.cn/">浙ICP备2022027583号</a></div><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"78f3a6e0\",\"movies_index.md\":\"6d564773\",\"posts_async.md\":\"c7940291\",\"posts_chrome_workflow.md\":\"dfdcf7cb\",\"posts_csp.md\":\"8b1e0799\",\"posts_eventloop.md\":\"c6caf8e8\",\"posts_form.md\":\"3add2ce3\",\"posts_friends_of_time_2023.md\":\"71b69490\",\"posts_git.md\":\"c90465ed\",\"posts_http_option.md\":\"9997527c\",\"posts_index.md\":\"279f248e\",\"posts_promise_next.md\":\"58ff639f\",\"posts_promise_prev.md\":\"4ddfbc45\",\"posts_rebuild_mac.md\":\"1be3b152\",\"posts_refactor_js.md\":\"76f8eb20\",\"posts_render_on_the_web.md\":\"0b11ff2c\",\"posts_restudy_function.md\":\"34c408f6\",\"posts_restudy_obj.md\":\"2fb56604\",\"posts_restudy_scope.md\":\"de7f7b3d\",\"posts_sourcemap.md\":\"259901c9\",\"posts_summary_2011.md\":\"ac21b29a\",\"posts_svg.md\":\"60324705\",\"posts_translate.md\":\"4dddf28e\",\"posts_vscode_setting.md\":\"26038331\",\"posts_vuepress_plugin_awesome_musicplayer.md\":\"8c0097a3\",\"posts_webpack_core.md\":\"d6397305\"}")</script>
    <script type="module" async src="/assets/app.ec7a89e7.js"></script>
    
  </body>
</html>