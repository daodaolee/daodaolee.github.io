<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器渲染机制、JS任务队列及事件循环</title>
    <meta name="description" content="A VitePress site">
    <link rel="stylesheet" href="/assets/style.b4de4daf.css">
    <link rel="modulepreload" href="/assets/chunks/Home.84031245.js">
    <link rel="modulepreload" href="/assets/chunks/Navbar.7a2e2f08.js">
    <link rel="modulepreload" href="/assets/chunks/Page.298bf9fa.js">
    <link rel="modulepreload" href="/assets/chunks/Post.8123d9ef.js">
    <link rel="modulepreload" href="/assets/chunks/Movie.e7531bdd.js">
    <link rel="modulepreload" href="/assets/app.ec7a89e7.js">
    <link rel="modulepreload" href="/assets/posts_eventloop.md.c6caf8e8.lean.js">
    
    <link rel="icon" href="/favicon.ico">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><div><header class="w-100vw p-6 flex items-center justify-between fixed" data-v-29c3ee47><a href="/" data-v-29c3ee47><img src="/logo-black.webp" class="w-10 h-10" data-v-29c3ee47></a><div class="nav-icons flex items-center gap-5" data-v-29c3ee47><!--[--><a target="_self" href="/posts/" class="cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="md:hidden" data-v-29c3ee47><div class="i-ri-article-line icon" data-v-29c3ee47></div></div><span text-sm ml-1 class="lt-md:hidden" data-v-29c3ee47>Posts</span></a><a target="_self" href="/movies/" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><!----><span text-sm ml-1 class="lt-md:hidden" data-v-29c3ee47>Movies</span></a><a target="_blank" href="https://github.com/daodaolee" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri:github-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://twitter.com/daodaolee_" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri:twitter-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://www.instagram.com/daodaoleee/" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri-instagram-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://dribbble.com/daodaolee" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri-dribbble-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://space.bilibili.com/294106298?spm_id_from=333.1007.0.0" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri-bilibili-fill icon" data-v-29c3ee47></div></div><!----></a><!--]--><a class="cursor-pointer op-60" data-v-29c3ee47><div class="i-ri:sun-line icon" data-v-29c3ee47></div></a></div></header><main class="content max-w-73ch mx-auto px-6 md:px-0 pb-15"><div class="pt-25"><div class="mb-8"><h1 class="title mt-0 text-2.2rem mb-5">浏览器渲染机制、JS任务队列及事件循环</h1><div class="op-60 flex items-end"><span>Jan 31, 2021</span><div class="text-0.85rem pl-1.8rem"><!--[--><span> #chrome  </span><span> #js  </span><!--]--></div></div></div><div style="position:relative;" class="page"><div><nav class="table-of-contents"><ul><li><a href="#进程和线程">进程和线程</a></li><li><a href="#浏览器">浏览器</a><ul><li><a href="#构成">构成</a></li><li><a href="#请求-响应">请求，响应</a></li><li><a href="#渲染">渲染</a></li></ul></li><li><a href="#js单线程">JS单线程</a></li><li><a href="#任务队列">任务队列</a></li><li><a href="#事件循环-event-loop">事件循环(Event Loop)</a><ul><li><a href="#概念">概念</a></li><li><a href="#定时器">定时器</a></li></ul></li><li><a href="#微任务、宏任务">微任务、宏任务</a></li></ul></nav><p>你是不是有过以下困难：</p><ul><li>多个方法互相嵌套，但是最终还是蒙对了</li><li>不是很明白为什么浏览器有时候会卡死</li><li>事件循环好像知道那么点，但是就是讲不出来为啥</li><li>……</li></ul><p>本篇文章就把你的问题给一一解答，当然这些东西想完弄清楚，肯定离不开<strong>进程</strong>，<strong>线程</strong>，<strong>浏览器内核</strong>，<strong>渲染</strong>，<strong>事件循环</strong>，任务队列等，我们就一个一个的来看，它们到底是怎么工作的。</p><h2 id="进程和线程" tabindex="-1">进程和线程 <a class="header-anchor" href="#进程和线程" aria-hidden="true">#</a></h2><p>举个例子，一个工厂，它有自己独立的资源，工厂和工厂之间相互独立，各自做各自的事情。一个场子可以有很多工人，工人可以 单个作业 也可以 协同作业，工人做的事情，都只会在自己的工厂内，并且共享这个工厂的空间。</p><p>我们现在把概念放到进程上，一个进程就相当于一个工厂，工厂里的资源就相当于系统分配的独立内存，多个工厂各自做各自的事情就相当于进程之间相互独立，一个工厂有很多工人就相当于一个进程可以有很多线程，工人的作业就相当于线程完成任务，工人共享这个工厂的空间，就相当于一个进程下面的线程之间可以共享程序的内存。</p><p><img src="https://i.loli.net/2021/01/31/tONwQshzkDrBpZF.png" alt="进程和线程"></p><p>在 <strong>windows</strong> 的任务管理器中 CPU 和 内存 可以把每个进程的占用看的很清楚，当然 <strong>Mac OS</strong> 从活动监视器中也可以看到。所以：<strong>进程是 cpu 资源分配的最小单位，线程是cpu调度的最小单位</strong>。</p><p><img src="https://i.loli.net/2021/01/31/q85RksFWeVrxNfK.png" alt="macOS"></p><p><img src="https://i.loli.net/2021/01/31/jznfuqWstbFwl8E.png" alt="windows"></p><p><strong>大家所说的多线程和单线程，都是只在一个进程内的多和单！</strong></p><h2 id="浏览器" tabindex="-1">浏览器 <a class="header-anchor" href="#浏览器" aria-hidden="true">#</a></h2><h3 id="构成" tabindex="-1">构成 <a class="header-anchor" href="#构成" aria-hidden="true">#</a></h3><p><em>前提：页面是跑在浏览器上的，也就是说浏览器是页面的载体，浏览器会制定一套规则，页面满足了这个规则然后才可以在到浏览器上正常运行。</em></p><p>浏览器本质上其实是一个软件，它运行在一个操作系统上(windows 或 MacOS 或 其他)，一般来说操作系统会开一个端口去运行这个软件，也就是为这个进程分配了CPU，内存 和 磁盘空间等。</p><p>那浏览器是单进程还是多进程呢？我们看一下：</p><p><img src="https://i.loli.net/2021/01/31/oi3gbNvJMl8sTaW.png" alt="进程"></p><p>可见它是个多个进程的浏览器！</p><p>在 Chrome 多进程架构里，它包括了四个进程：</p><ul><li>Browser进程（负责地址栏、书签栏、前进后退、网络请求、文件访问等）</li><li>Renderer进程（<strong>负责一个Tab内所有和网页渲染有关的所有事情，是最核心的进程</strong>）</li><li>GPU进程（负责GPU相关的任务）</li><li>Plugin进程（负责Chrome插件相关的任务）</li></ul><p>如果你打开它的任务管理器，你会发现：</p><p><img src="https://i.loli.net/2021/01/31/7vsm89SFdLMwTZk.png" alt="chrome的任务管理器"></p><p>上图我们可以看出：一个标签页就是一个进程，甚至一个扩展程序就是一个进程！在浏览器中打开一个网页就相当于新开了一个进程。</p><p><strong>但是：在这里浏览器有自己的优化机制，有时候打开多个标签页，进程会合并，所以每一个标签页对应一个进程不是绝对的。</strong></p><p>这样的多进程分配的好处是：</p><ul><li>如果一个页面挂了，不会影响其他页面，甚至影响到整个浏览器</li><li>避免安装的三方插件等影响了浏览器全局</li><li>多进程充分利用了多核的优势</li><li>把插件，扩展程序等全部隔离，提高稳定性</li></ul><p>当然，缺点很就明显了，内存消耗大，确实有点像空间换时间的意思。</p><h3 id="请求-响应" tabindex="-1">请求，响应 <a class="header-anchor" href="#请求-响应" aria-hidden="true">#</a></h3><p>接下来我们看下浏览器是如何通过输入内容来请求成功的。</p><ol><li><p>当用户在地址栏输入内容时，UI线程首先问的是“这是搜索查询还是URL？”。在Chrome浏览器中，地址栏也是搜索输入字段，因此UI线程需要解析并决定是将您发送到搜索引擎还是请求的网站。</p><p><img src="https://i.loli.net/2021/01/31/YRkZwCcaKbHQJrf.png" alt="UI线程询问输入是搜索查询还是URL"></p></li><li><p>当用户按下Enter键时，UI线程会发起网络调用以获取网站内容。加载微调框显示在选项卡的角上，并且网络线程通过相应的协议（例如DNS查找和为请求建立TLS连接）。</p><p>此时，网络线程可能会收到服务器重定向标头，例如HTTP301。在这种情况下，网络线程与服务器正在请求重定向的UI线程进行通信。然后，将启动另一个URL请求。</p><p><img src="https://i.loli.net/2021/01/31/oThNMwPYd2tSniV.png" alt="UI线程与网络线程交谈以导航至mysite.com"></p></li><li><p>一旦有响应了，网络线程将在必要时查看流的前几个字节。响应的Content-Type标头应说明它是什么数据类型，但是由于可能丢失或错误， 因此在此处进行MIME Type检查。</p><p>如果响应是HTML文件，则下一步是将数据传递到渲染器进程，但是如果是zip文件或其他文件，则意味着这是下载请求，因此它们需要将数据传递到下载管理器。</p><p><img src="https://i.loli.net/2021/01/31/r6d4iczGNKPeXSg.png" alt="响应头包含Content-Type和有效载荷，有效载荷是实际数据"></p></li><li><p>网络线程从安全站点询问响应数据是否为HTML，并进行安全检查。</p><p><img src="https://i.loli.net/2021/01/31/QtOaw7foH4rMYnS.png" alt="网络线程从安全站点询问响应数据是否为HTML"></p><p>在这个时候，浏览器已经拿到响应了，接下来就开始进行渲染了。</p></li><li><p>一旦完成所有检查，并且Network线程确信浏览器应导航到请求的站点，则Network线程将告知UI线程数据已准备就绪。然后，UI线程找到一个渲染器进程来进行网页渲染。</p><p><img src="https://i.loli.net/2021/01/31/XE7mOI4DY5L8qP1.png" alt="网络线程告诉UI线程查找渲染器进程"></p></li><li><p>现在已经准备好数据和渲染器进程，将IPC从浏览器进程发送到渲染器进程以提交导航。它还会传递数据流，因此渲染器进程可以继续接收HTML数据。一旦浏览器进程听到确认已在渲染器进程中进行提交的确认，导航即完成，文档加载阶段开始。</p><p>此时，地址栏已更新，安全指示符和站点设置UI反映了新页面的站点信息。选项卡的会话历史记录将被更新，因此后退/前进按钮将逐步浏览刚刚导航到的站点。为了方便在关闭选项卡或窗口时恢复选项卡/会话，会话历史记录存储在磁盘上。</p><p><img src="https://i.loli.net/2021/01/31/vw3jBpUnIEf8Dxs.png" alt="浏览器和渲染器进程之间的IPC，请求渲染页面"></p><p><img src="https://i.loli.net/2021/01/31/yCzPAlLBwdtOKEI.png" alt="从渲染器到浏览器的IPC进程通知页面已“加载”"></p></li></ol><p>到这里为止，浏览器的请求和响应就完成了。那在响应之后如何渲染呢，我们接着往下看</p><h3 id="渲染" tabindex="-1">渲染 <a class="header-anchor" href="#渲染" aria-hidden="true">#</a></h3><p>先说几个渲染进程内将要工作的线程：</p><ul><li>主线程(Main thread)：<strong>下载资源、执行js、计算样式、进行布局、绘制合成</strong></li><li>光栅线程（Raster thread）</li><li>合成线程（Compositor thread）</li><li>工作线程（Worker thread）</li></ul><p>在下面的渲染过程中，其实就是这四个进程的互相配合，我们一起来看下吧。</p><ol><li><p>当渲染过程接收提交消息用于导航和开始接收HTML数据，主线程开始解析文本串（HTML），使之成为一个 <code>Document Object Model</code> ，也就是 <strong>DOM</strong>。</p></li><li><p>网站有用到图片，CSS 和JavaScript的话，这些东西需要从网络或者缓存中加载，主线程可以边请求，边预加载构建DOM。</p><p><img src="https://i.loli.net/2021/01/31/iUmOeJc1daWs2Z9.png" alt="主线程解析HTML并构建DOM树"></p></li><li><p>当HTML解析器找到 <code>&lt;script&gt;</code> 标签后，将会暂停HTML解析，并且必须加载、解析和执行 JavaScript的代码。为什么？因为JavaScript 可以使用诸如 <code>document.write()</code> 更改整个DOM结构！所以开发人员在写代码的时候可以在 <code>&lt;script&gt;</code> 标签上加 <code>async</code> 或者 <code>defer</code> 属性。然后浏览器将会异步加载并运行JavaScript，不会阻止解析。</p></li><li><p>主线程解析CSS样式，并把CSS样式一一对应到DOM节点上，注意，此时CSS页面还没有生效，只是样式和节点绑定了关系。</p><p><img src="https://i.loli.net/2021/01/31/CYHbptVyWI3TwmS.png" alt="主线程解析CSS以添加计算样式"></p></li><li><p>接下来CSS根据DOM节点，会生成类似于DOM结构的一个布局树，仅包含了页面上可见内容的信息，如果有 <code>display: none</code> 等，则该元素不属于布局树。如果有<code>p::before {content: &quot;123&quot;}</code> 等伪类的存在，就算它不在DOM中，也会包含在布局树中。</p><p><img src="https://i.loli.net/2021/01/31/NwxgPsyOqojVh2p.png" alt="主线程遍历具有计算样式的DOM树并生成布局树"></p><p>在此绘制步骤中，主线程遍历布局树以创建绘制记录。绘画记录是绘画过程的注释，例如“先是背景，然后是文本，然后是矩形”，类似 <code>canvas</code>。</p><p>注意：在渲染的时候，每个步骤前面操作的结果都用于创建新数据，如果布局树发生了更改，文档受影响的部分就会重新绘制，也就是 <strong>重绘</strong>，开发过程中要尽量避免这一现象。</p></li><li><p>至此浏览器知道了：文档的结构，每个DOM元素的样式，页面的几何形状以及绘制的顺序。把这些东西换转为屏幕上像素我们称之为 <strong>光栅化</strong>。在现代浏览器中执行这一行为的过程，称为 <strong>合成(Compositing)</strong>，就是把页面各个部分分成若干层，分别进行栅格化，然后合成器线程的单独线程中进行合成，一个层可以称之为一个 layer。</p><p><img src="https://i.loli.net/2021/01/31/KkTc9AaRDru4iGQ.png" alt="主线程遍历布局树生成层树"></p></li><li><p>层分好了并确定了顺序之后，主线程就把这个信息提交给合成线程，然后合成器线程把每个图层栅格化，发送给栅格线程，栅格线程把它们存储在GPU内存内。</p><p><img src="https://i.loli.net/2021/01/31/GxOo9LUg2EY7HXi.png" alt="光栅线程创建图块的位图并发送到GPU"></p></li><li><p>最终，合成线程将栅格化的块合成帧，并通过IPC传递给浏览器进程，显示在屏幕上。</p><p><img src="https://i.loli.net/2021/01/31/E9xCQJ1vSYoGegl.png" alt="合成器线程创建合成框架。帧发送到浏览器进程，然后发送到GPU"></p></li></ol><p>至此，浏览器的请求，响应和渲染过程结束！</p><p>（一半了，稍微休息一下，我们再继续！）</p><h2 id="js单线程" tabindex="-1">JS单线程 <a class="header-anchor" href="#js单线程" aria-hidden="true">#</a></h2><p>回顾一下，浏览器的渲染进程中，主线程里包括了执行JS，那也就意味着：</p><p><strong>JS在浏览器的 渲染进程(Rendered Process) 的 主线程(Main Thread) 内</strong>！</p><p><img src="https://i.loli.net/2021/01/31/6qvbFOlATQeai2U.png" alt="JS在主线程内"></p><p><strong>记住：JS是被设计成单线程的！</strong></p><blockquote><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ —— 阮一峰</p></blockquote><p>所以叙述出来就是：JS逻辑 和 UI渲染 是在一个线程中顺序发生的，二者同一时间只可以存在一个。继续回顾一下上面渲染所提到的，HTML解析器必须等待JS运行，JS是可以操作DOM 和 布局树的，会干扰到主线程在解析HTML的顺序，从而影响结果，所以为了页面的渲染统一，JS被设计成了 执行阻塞UI渲染型。</p><p>同时也反映出了一个问题：JS过多会造成页面卡顿，因为走不下去了。所以JS的逻辑一定不能冗余。</p><h2 id="任务队列" tabindex="-1">任务队列 <a class="header-anchor" href="#任务队列" aria-hidden="true">#</a></h2><p>既然JS是单线程，也就意味着里面的逻辑是排队运行的，后一个任务必须等前一个结束才可以运行。这样就会出一个问题，有没有一种可能是挂起不那么重要的任务，先走重要的，等结束之后再执行挂起的任务呢？</p><p>按照这个说法的话，所有任务就可以分成：<strong>同步任务(sync)</strong> 和 <strong>异步任务(async)</strong> ，同步任务就是主线程里面的排队进行，异步任务就是不进入主线程，进入一个 “任务队列(task queue)” 的地方呆着，看着主线程里的任务进行，一旦发现主线程的同步任务执行完了，就通知主线程，说我这里的异步任务可以执行了，该任务才会进入主线程执行。</p><p>所以有没有发现，那些鼠标点击事件，页面滚动，回调函数，http请求……其实就在任务队列里面。</p><h2 id="事件循环-event-loop" tabindex="-1">事件循环(Event Loop) <a class="header-anchor" href="#事件循环-event-loop" aria-hidden="true">#</a></h2><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-hidden="true">#</a></h3><p>有了任务队列的存在，就会有事件循环的存在，因为任务队列中可能有很多任务，一个在任务队列的任务进入到主线程后，任务队列依然会看着主线程，看看刚进去的这个有没有执行完毕，毕竟任务队列里还有很多没执行的任务，所以主线程去读取任务队列是循环不断的，也就叫做了 <strong>事件循环</strong>。</p><p>这里放张网图，基本上一看就明白了（参考自Philip Roberts的演讲《<a href="http://vimeo.com/96425312" target="_blank" rel="noreferrer">Help, I&#39;m stuck in an event-loop</a>》）</p><p><img src="https://i.loli.net/2021/01/31/DwyaGmCNZA5dgep.png" alt="事件循环"></p><h3 id="定时器" tabindex="-1">定时器 <a class="header-anchor" href="#定时器" aria-hidden="true">#</a></h3><p>这个有点特殊，单独讲一下。</p><p>定时器不是个异步事件，是一个定时事件，但是仍属于一个回调操作，是被放在任务队列中的。</p><p>就算定时器被设置的时间是0，它也仍然会在主线程逻辑走完之后(此时栈清空了)，再执行，所以时间是0的定时器，它可以被理解为希望尽早的执行。</p><blockquote><p>需要注意的是，setTimeout()只是将事件插入了&quot;任务队列&quot;，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。 ——阮一峰</p></blockquote><h2 id="微任务、宏任务" tabindex="-1">微任务、宏任务 <a class="header-anchor" href="#微任务、宏任务" aria-hidden="true">#</a></h2><p>这段参考<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noreferrer">Tasks, microtasks, queues and schedules</a>，一位谷歌开发者人员用实例讲述了任务执行顺序，并带有在线Demo，强烈建议过一遍(英语不好就逐句翻译)。</p><p>在JS中，主线程的任务叫 <code>宏任务(MacroTask)</code> ，宏任务执行完毕后，立即执行的任务叫 <code>微任务(MicroTask)</code> 。</p><p><strong>宏任务：</strong></p><ul><li>主线程已经存在了的任务叫宏任务，从任务队列中进入主线程的任务也叫宏任务，一个宏任务执行过程中，从头到尾不会执行其他的东西</li><li>浏览器会在一个宏任务结束后，在下一个宏任务开始前，对页面进行重新渲染</li></ul><p><strong>微任务：</strong></p><ul><li>当前宏任务执行结束后立即执行的任务叫微任务，也就是说它在前宏任务之后，后宏任务之前，渲染之前！</li><li>它的速度比定时器要快，因为不用等待渲染，定时器是宏任务</li><li>在一个宏任务执行结束后，所有的微任务都会执行完毕(渲染前)</li></ul><p>基于上面的概念，我们可以给常用的任务分下类：</p><ul><li>宏任务：主代码，setTimeout，setInterval，setImmediate，requestAnimationFrame，I/O，UI渲染</li><li>微任务：Promise，process.nextTick，MutationObserve，queueMicrotask</li></ul><p>当然 Vue 中的 nextTick 也就属于微任务了，最后放一张图帮助一下理解：</p><p><img src="https://i.loli.net/2021/01/31/ezIH3RLdm9C8OlS.png" alt="宏任务和微任务"></p><p>参考资料：</p><ul><li><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html#comment-text" target="_blank" rel="noreferrer">JavaScript 运行机制详解：再谈Event Loop</a></p></li><li><p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noreferrer">Event Loops</a></p></li><li><p><a href="https://segmentfault.com/a/1190000022950333" target="_blank" rel="noreferrer">浅谈浏览器架构、单线程js、事件循环、消息队列、宏任务和微任务</a></p></li><li><p><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noreferrer">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p></li><li><p><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part2" target="_blank" rel="noreferrer">Inside look at modern web browser (part 2)</a></p></li><li><p><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3" target="_blank" rel="noreferrer">Inside look at modern web browser (part 3)</a></p></li><li><p><a href="https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model" target="_blank" rel="noreferrer">overview-of-the-parsing-model</a></p></li><li><p><a href="https://www.infoq.cn/article/CS9-WZQlNR5h05HHDo1b" target="_blank" rel="noreferrer">史上最全！图解浏览器的工作原理</a></p></li></ul></div></div></div></main></div></div><div class="text-center text-[14px] pt-10 pb-2 scale-80 color-[black]" style="letter-spacing:0.2rem;"><a href="https://beian.miit.gov.cn/">浙ICP备2022027583号</a></div><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"78f3a6e0\",\"movies_index.md\":\"6d564773\",\"posts_async.md\":\"c7940291\",\"posts_chrome_workflow.md\":\"dfdcf7cb\",\"posts_csp.md\":\"8b1e0799\",\"posts_eventloop.md\":\"c6caf8e8\",\"posts_form.md\":\"3add2ce3\",\"posts_friends_of_time_2023.md\":\"71b69490\",\"posts_git.md\":\"c90465ed\",\"posts_http_option.md\":\"9997527c\",\"posts_index.md\":\"279f248e\",\"posts_promise_next.md\":\"58ff639f\",\"posts_promise_prev.md\":\"4ddfbc45\",\"posts_rebuild_mac.md\":\"1be3b152\",\"posts_refactor_js.md\":\"76f8eb20\",\"posts_render_on_the_web.md\":\"0b11ff2c\",\"posts_restudy_function.md\":\"34c408f6\",\"posts_restudy_obj.md\":\"2fb56604\",\"posts_restudy_scope.md\":\"de7f7b3d\",\"posts_sourcemap.md\":\"259901c9\",\"posts_summary_2011.md\":\"ac21b29a\",\"posts_svg.md\":\"60324705\",\"posts_translate.md\":\"4dddf28e\",\"posts_vscode_setting.md\":\"26038331\",\"posts_vuepress_plugin_awesome_musicplayer.md\":\"8c0097a3\",\"posts_webpack_core.md\":\"d6397305\"}")</script>
    <script type="module" async src="/assets/app.ec7a89e7.js"></script>
    
  </body>
</html>