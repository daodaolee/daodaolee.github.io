<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Web渲染的权衡</title>
    <meta name="description" content="A VitePress site">
    <link rel="stylesheet" href="/assets/style.b4de4daf.css">
    <link rel="modulepreload" href="/assets/chunks/Home.84031245.js">
    <link rel="modulepreload" href="/assets/chunks/Navbar.7a2e2f08.js">
    <link rel="modulepreload" href="/assets/chunks/Page.298bf9fa.js">
    <link rel="modulepreload" href="/assets/chunks/Post.8123d9ef.js">
    <link rel="modulepreload" href="/assets/chunks/Movie.e7531bdd.js">
    <link rel="modulepreload" href="/assets/app.ec7a89e7.js">
    <link rel="modulepreload" href="/assets/posts_render_on_the_web.md.0b11ff2c.lean.js">
    
    <link rel="icon" href="/favicon.ico">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><div><header class="w-100vw p-6 flex items-center justify-between fixed" data-v-29c3ee47><a href="/" data-v-29c3ee47><img src="/logo-black.webp" class="w-10 h-10" data-v-29c3ee47></a><div class="nav-icons flex items-center gap-5" data-v-29c3ee47><!--[--><a target="_self" href="/posts/" class="cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="md:hidden" data-v-29c3ee47><div class="i-ri-article-line icon" data-v-29c3ee47></div></div><span text-sm ml-1 class="lt-md:hidden" data-v-29c3ee47>Posts</span></a><a target="_self" href="/movies/" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><!----><span text-sm ml-1 class="lt-md:hidden" data-v-29c3ee47>Movies</span></a><a target="_blank" href="https://github.com/daodaolee" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri:github-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://twitter.com/daodaolee_" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri:twitter-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://www.instagram.com/daodaoleee/" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri-instagram-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://dribbble.com/daodaolee" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri-dribbble-line icon" data-v-29c3ee47></div></div><!----></a><a target="_blank" href="https://space.bilibili.com/294106298?spm_id_from=333.1007.0.0" class="lt-md:hidden cursor-pointer op-60 transition-colors-300" data-v-29c3ee47><div text-xl class="" data-v-29c3ee47><div class="i-ri-bilibili-fill icon" data-v-29c3ee47></div></div><!----></a><!--]--><a class="cursor-pointer op-60" data-v-29c3ee47><div class="i-ri:sun-line icon" data-v-29c3ee47></div></a></div></header><main class="content max-w-73ch mx-auto px-6 md:px-0 pb-15"><div class="pt-25"><div class="mb-8"><h1 class="title mt-0 text-2.2rem mb-5">Web渲染的权衡</h1><div class="op-60 flex items-end"><span>Dec 13, 2021</span><div class="text-0.85rem pl-1.8rem"><!--[--><span> #chrome  </span><span> #performance  </span><!--]--></div></div></div><div style="position:relative;" class="page"><div><nav class="table-of-contents"><ul><li><a href="#术语">术语</a><ul><li><a href="#渲染">渲染</a></li><li><a href="#表现">表现</a></li></ul></li><li><a href="#服务器渲染">服务器渲染</a></li><li><a href="#静态渲染">静态渲染</a></li><li><a href="#服务器渲染和静态渲染">服务器渲染和静态渲染</a></li><li><a href="#客户端渲染">客户端渲染</a></li><li><a href="#rehydration下的ssr和csr">rehydration下的SSR和CSR</a></li><li><a href="#流式服务器渲染和渐进式同构">流式服务器渲染和渐进式同构</a></li><li><a href="#三体渲染">三体渲染</a></li><li><a href="#总结">总结</a></li><li><a href="#参考资料">参考资料</a></li></ul></nav><p>构建网站的方法有很多，但是每种构建都离不开渲染，那如何从性能的角度来权衡Web上的渲染呢？</p><h2 id="术语" tabindex="-1">术语 <a class="header-anchor" href="#术语" aria-hidden="true">#</a></h2><h3 id="渲染" tabindex="-1">渲染 <a class="header-anchor" href="#渲染" aria-hidden="true">#</a></h3><ul><li><strong>SSR</strong>：服务器渲染，在服务器上将客户端或通用程序渲染为 HTML。</li><li><strong>CSR</strong>：客户端渲染， 在浏览器中渲染程序，通常使用 DOM。</li><li><strong>Rehydration</strong>：同构渲染，复用服务器渲染的 HTML 的 DOM 树和数据后，在客户端再进行渲染。</li><li><strong>Prerendering</strong>：预渲染，在构建时运行客户端程序以将其初始状态捕获为静态 HTML。</li></ul><h3 id="表现" tabindex="-1">表现 <a class="header-anchor" href="#表现" aria-hidden="true">#</a></h3><ul><li><strong>TTFB</strong>：第一个字节出现的时间，被看作单击链接和第一次内容进入的时间。</li><li><strong>FP</strong>：First Paint，像素第一次可见。</li><li><strong>FCP</strong>：First Contentful Paint，请求的内容（比如正文）第一次可见。</li><li><strong>TTI</strong>：Time To Interactive，页面变为可交互的时间（事件连接等）。</li></ul><h2 id="服务器渲染" tabindex="-1">服务器渲染 <a class="header-anchor" href="#服务器渲染" aria-hidden="true">#</a></h2><p><em>服务器渲染为服务器上的页面生成完整的 HTML 以响应<a href="https://juejin.cn/post/7039036362653171742#heading-10" target="_blank" rel="noreferrer">导航</a>。这避免了在客户端上进行数据获取和模板化 的额外开销，因为它是在浏览器获得响应之前处理的。</em></p><p>服务器渲染会产生比较快的 <code>首次绘制(FP)</code> 和 <code>首次内容绘制(FCP)</code>。在服务器上运行页面逻辑和渲染可以避免向客户端发送大量 JavaScript，这有助于实现快速的 <code>交互时间(TTI)</code>。因为通过服务器渲染，实际上只是将文本和链接发送到用户的浏览器。这种方法可以很好地适用于各种设备和网络条件，并开启了浏览器优化，例如流式文档解析。</p><p><img src="https://cdn.jsdelivr.net/gh/daodaolee/photobed@main/img/20211213145054.png" alt=""></p><p>服务器渲染的话，用户不太可能在访问站点前等待 CPU-bound（计算密集型）处理JavaScript。即使在三方JS无法避免的情况下，使用服务器渲染来降低自己的当前JS成本，可以有更多的性能预算。</p><blockquote><ul><li>CPU-bound：计算密集型，表示在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序。</li><li>性能预算：一个团队不能允许超过的页面<strong>限制</strong>，<a href="https://juejin.cn/post/6844903700524171271" target="_blank" rel="noreferrer">点击查看链接</a></li></ul></blockquote><p>但是这种方法有一个主要缺点：在服务器上生成页面需要的时间，会导致 <code>首字母时间（TTFB）</code>变慢。</p><p>服务端渲染能不能满足当前的系统取决于构建的前端体验类型。有关服务器渲染和客户端渲染一直存在着长期的争论，但是要注意的是，可以对某些页面使用服务器渲染。</p><p>许多现代框架、库和体系结构支持在客户端和服务端起上呈现相同的程序，这些技术可用于服务器渲染，在使用的时候，注意它们在渲染发生在客户端和服务器端的方案的实现。</p><h2 id="静态渲染" tabindex="-1">静态渲染 <a class="header-anchor" href="#静态渲染" aria-hidden="true">#</a></h2><p>静态渲染发生在构建时，并提供快速的 <code>首次绘制（FP）</code>、<code>首次内容绘制（FCP）</code> 和 <code>交互时间（TTI）</code>，和服务器渲染不同，他还会实现快速的 <code>首次首字节时间（TTFB）</code>，因为页面的HTML不必即时生成。一般，静态渲染意味着提前为每个URL生成单独的HTML文件，通过提前生成HTML，静态渲染可以部署到多个CDN，从而利用 <a href="https://www.easemob.com/news/7325" target="_blank" rel="noreferrer">边缘缓存</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/daodaolee/photobed@main/img/20211213151915.png" alt=""></p><p>静态渲染的缺点之一是必须为每个可能的URL生成单独的HTML文件。如果无法提前预测这些URL的内容，有可能就无法通过静态渲染实现。这里说一下静态渲染和预渲染之间的区别：静态渲染是交互式的，无需执行大量客户端JS，而预渲染改进了必须启动的 <code>SPA（单页应用程序）</code> 的首次绘制或者首次绘制内容以使页面真正具有交互性。<em>这个可以通过看博客渲染引擎（类似jekyll等）和SPA应用的区别会有所理解。</em></p><p>如果不确定是要用静态渲染还是预渲染，可以这样测试一下：禁用JavaScript并加载创建的网页。对于静态渲染的页面，大多数功能在没有启用JavaScript的情况下依然可用。而对于预渲染页面，虽然仍然有一些基本功能，比如链接，但是大多数页面是不可用 的。</p><p>还可以使用控制台网络板块，降低网络速度，并观察在页面变为可交互之前下载了多少JavaScript。预渲染通常需要更多的JavaScript才可以交互，而且 JavaScript 往往比静态渲染使用的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Progressive_Enhancement" target="_blank" rel="noreferrer">渐进增强</a>方法更复杂。</p><h2 id="服务器渲染和静态渲染" tabindex="-1">服务器渲染和静态渲染 <a class="header-anchor" href="#服务器渲染和静态渲染" aria-hidden="true">#</a></h2><p>服务器渲染的动态特性会带来大量的 <a href="https://medium.com/airbnb-engineering/operationalizing-node-js-for-server-side-rendering-c5ba718acfc9" target="_blank" rel="noreferrer">计算开销</a>。许多服务器渲染方案不会提前刷新，可能会延迟 TTFB 或者将发送到数据加倍。在React中，<code>renderToString()</code> 可能很慢，因为它是同步和单线程的。服务器渲染正确的使用，可能离不开组件缓存、内存消耗、<a href="https://speakerdeck.com/maxnajim/hastening-react-ssr-with-component-memoization-and-templatization" target="_blank" rel="noreferrer">应用记忆技术</a>等其他问题，仅仅因为服务器渲染可以使某些内容更快的显示出来，并不代表所做的工作少。</p><p>服务器渲染为每个URL按需生成HTML，但可能会比仅提供静态渲染的内容慢。如果可以的话，服务器渲染 <strong>+</strong> <a href="https://freecontent.manning.com/caching-in-react/" target="_blank" rel="noreferrer">HTML缓存</a>可以大大减少服务器渲染时间。与静态渲染相比，服务器渲染的优势在于可以提取更多“动态”数据并响应完整的请求。需要个性化的页面是不是和静态渲染的。</p><h2 id="客户端渲染" tabindex="-1">客户端渲染 <a class="header-anchor" href="#客户端渲染" aria-hidden="true">#</a></h2><p><em>客户端渲染是指用JavaScript直接在浏览器里渲染页面。所有的逻辑、获取数据、模板、路由都在客户端处理。</em></p><p>对于移动设备，客户端渲染可能很难使用并且一直能快速执行。如果可以做最少的工作，保持最少的JavaScript性能预算并尽可能减少 <a href="https://blog.csdn.net/qq_38890412/article/details/106663674" target="_blank" rel="noreferrer">往返时延（RTT）</a>， 它就可以有接近纯服务器渲染的性能。可以使用http2，或者 <code>&lt;link rel=preload&gt;</code>，这样可以让解析器更快的工作。</p><p><img src="https://cdn.jsdelivr.net/gh/daodaolee/photobed@main/img/20211213163255.png" alt=""></p><p>客户端渲染的主要缺点是所需的 JavaScript 量往往会随着应用程序的增长而增长，比如添加了新的库、polyfill、三方代码等。它们会争夺页面的处理顺序，并且通常必须在渲染页面内容之前处理。所以在使用依赖大型JavaScript包的CSR构建时，应该考虑代码拆分，并确保延迟加载JavaScript，也就是按需加载：只在需要时提供需要的服务。</p><h2 id="rehydration下的ssr和csr" tabindex="-1">rehydration下的SSR和CSR <a class="header-anchor" href="#rehydration下的ssr和csr" aria-hidden="true">#</a></h2><p>hydration直译为水合，可以理解为对曾经渲染过的HTML进行重新渲染的过程，rehydration可以理解为一种使用水合的技术，也被叫做同构渲染。</p><p>该方法会同时进行服务器渲染和客户端渲染，以权衡渲染平衡。这样的首次内容绘制会很快，就像服务器渲染一样，然后用一个同构技术（rehydration）在客户端再次渲染。</p><p>该技术主要的缺点就是，执行JS之前，什么也做不了，下面是一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/daodaolee/photobed@main/img/20211213165856.png" alt=""></p><p>服务器返回页面节点，也就是三个checkbox，也会返回DATA，再加载JS脚本，只有 bundle.js 完成加载和执行之后，页面才变成交互式。</p><p><img src="https://cdn.jsdelivr.net/gh/daodaolee/photobed@main/img/20211213163143.png" alt=""></p><h2 id="流式服务器渲染和渐进式同构" tabindex="-1">流式服务器渲染和渐进式同构 <a class="header-anchor" href="#流式服务器渲染和渐进式同构" aria-hidden="true">#</a></h2><p>流式服务器渲染允许以块的形式发送HTML，浏览器接收到之后把他们拼接渲染。这样可以有快速的首次绘制和首次内容绘制。</p><p>使用渐进式同构的话，服务器渲染的程序的各个部分会随着时间的推移而执行，而不是当前一次就初始化整个程序。这样可以推迟页面低优先级部分的代码以防止阻塞主线程。</p><h2 id="三体渲染" tabindex="-1">三体渲染 <a class="header-anchor" href="#三体渲染" aria-hidden="true">#</a></h2><p>结合 Service Worker 的话，三题渲染技术也可以使用。可以使用流式服务器渲染进行初始导航，然后让 Service Worker 安装后为导航渲染HTML。这可以使缓存的组件和模板保持最新，并启用 SPA 样式的导航以在同一会话中渲染新视图。如果可以在服务器、客户端页面和 Service Worker 之间共享相同的模板和路由代码，三体渲染是个不错的选择。</p><p><img src="https://cdn.jsdelivr.net/gh/daodaolee/photobed@main/img/20211213165517.png" alt=""></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><p>下图为服务器-客户端渲染到范围，可以参照下图来决定使用哪种渲染方式：</p><p><img src="https://cdn.jsdelivr.net/gh/daodaolee/photobed@main/img/20211213165749.png" alt=""></p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-hidden="true">#</a></h2><ul><li><a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web" target="_blank" rel="noreferrer">Rendering on the Web </a></li><li><a href="https://zhuanlan.zhihu.com/p/62766037" target="_blank" rel="noreferrer">什么是CPU密集型、IO密集型？</a></li><li><a href="https://juejin.cn/post/6844903700524171271" target="_blank" rel="noreferrer">开启性能预算</a></li><li><a href="https://blog.csdn.net/qq_38890412/article/details/106663674" target="_blank" rel="noreferrer">傻子都能看懂的——RTT</a></li><li><a href="https://ssr.vuejs.org/zh/guide/streaming.html#%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E8%AF%B4%E6%98%8E-streaming-caveats" target="_blank" rel="noreferrer">Vue SSR 流式渲染</a></li><li><a href="https://www.zhihu.com/question/379831174" target="_blank" rel="noreferrer">前端同构应用和SSR有什么区别</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Progressive_Enhancement" target="_blank" rel="noreferrer">渐进增强</a></li></ul></div></div></div></main></div></div><div class="text-center text-[14px] pt-10 pb-2 scale-80 color-[black]" style="letter-spacing:0.2rem;"><a href="https://beian.miit.gov.cn/">浙ICP备2022027583号</a></div><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"78f3a6e0\",\"movies_index.md\":\"6d564773\",\"posts_async.md\":\"c7940291\",\"posts_chrome_workflow.md\":\"dfdcf7cb\",\"posts_csp.md\":\"8b1e0799\",\"posts_eventloop.md\":\"c6caf8e8\",\"posts_form.md\":\"3add2ce3\",\"posts_friends_of_time_2023.md\":\"71b69490\",\"posts_git.md\":\"c90465ed\",\"posts_http_option.md\":\"9997527c\",\"posts_index.md\":\"279f248e\",\"posts_promise_next.md\":\"58ff639f\",\"posts_promise_prev.md\":\"4ddfbc45\",\"posts_rebuild_mac.md\":\"1be3b152\",\"posts_refactor_js.md\":\"76f8eb20\",\"posts_render_on_the_web.md\":\"0b11ff2c\",\"posts_restudy_function.md\":\"34c408f6\",\"posts_restudy_obj.md\":\"2fb56604\",\"posts_restudy_scope.md\":\"de7f7b3d\",\"posts_sourcemap.md\":\"259901c9\",\"posts_summary_2011.md\":\"ac21b29a\",\"posts_svg.md\":\"60324705\",\"posts_translate.md\":\"4dddf28e\",\"posts_vscode_setting.md\":\"26038331\",\"posts_vuepress_plugin_awesome_musicplayer.md\":\"8c0097a3\",\"posts_webpack_core.md\":\"d6397305\"}")</script>
    <script type="module" async src="/assets/app.ec7a89e7.js"></script>
    
  </body>
</html>